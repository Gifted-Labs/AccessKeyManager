package com.juls.accesskeymanager.services;

import java.sql.Date;
import java.time.LocalDate;
import java.util.*;
import java.util.stream.Collectors;

import com.juls.accesskeymanager.exceptions.NotFoundException;
import jakarta.transaction.Transactional;
import lombok.AllArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.http.HttpStatus;
import org.springframework.security.access.prepost.PostAuthorize;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import org.springframework.web.bind.annotation.ResponseStatus;

import com.juls.accesskeymanager.data.models.AccessKeyDetails;
import com.juls.accesskeymanager.data.models.AccessKeys;
import com.juls.accesskeymanager.data.models.Status;
import com.juls.accesskeymanager.data.repository.AccessKeyRepo;
import com.juls.accesskeymanager.exceptions.BadRequestException;

import lombok.RequiredArgsConstructor;

import static java.util.stream.Collectors.toList;

/**
 * @author Julius Adjetey Sowah
 * @version 1.0
 * The AccessKeyService class contains all the services a user can perform on the application. It comprises all
 * the methods and functions both the users with authority of 'ADMIN' and 'USER' can perform on the application.
 * It makes use of the accessKeyRepo and userService classes to perform it's operations.
 */

@Slf4j
@Service
@RequiredArgsConstructor
public class AccessKeyService {

    private final AccessKeyRepo accessKeyRepo;
    private final UserServiceImpl userService;


    /**
     * The getAllAccessKeys method is used by the admin to get
     * the list of all the access keys created by users of the application. And
     * it is viewed on the admin's dashboard.
     * @return List<AccessKeyDetails> The list of all the accesskeys created on the application
     */

    public List<AccessKeyDetails> getAllAccessKeys(){
        List <AccessKeys> accessKeys = this.accessKeyRepo.findAll();
        return accessKeys.stream().map(this::convertToAccessKeyDetails).toList();

    }


    /**
     * The getAllKeysByEmail method is used to get the list of all keys created by a particular user. This function
     * can be performed by both the user and the admin. It contains all keys, whether they are active, revoked or
     * expired.
     * @apiNote It requires that anyone who wants to access method must have an authority of either 'ADMIN' or 'USER'
     * @param email The email of the user whose keys you want to find
     * @return List</AccessKeyDetails> The list of all the keys generated by that particular user.
     */

    public List <AccessKeyDetails> getAllKeysByEmail(String email){
        var user = this.userService.getUserByEmail(email);
        if (user==null){
            throw new UsernameNotFoundException("No user exist with this email");
        }
        List <AccessKeys> accessKeys = this.accessKeyRepo.findByUser(user);
        return accessKeys.stream().map(this::convertToAccessKeyDetails).toList();

    }

    /**
     * The getActiveKeyByEmail method is used to get the active key attributed to a particular user. It requires
     * the email of the user who's active key is needed;
     * @apiNote To access this method you need the authority of an 'ADMIN'.
     * @param email The email of the user who the admin want's to retrieve his active key
     * @return activeKey The active key of the user.
     */

    public AccessKeyDetails getActiveKeyByEmail(String email){

        // Get the list of all the keys generated by the user;
        List <AccessKeyDetails> keys = getAllKeysByEmail(email);

        // Loop through all the keys of the user to find the active key.
        AccessKeyDetails activeKey = null;
        for (AccessKeyDetails keyDetails : keys){

            //Check if the key is active and assign it to the active key.
            if (keyDetails.getStatus().equals(Status.ACTIVE)){
                activeKey = keyDetails;
            }
        }
        return activeKey;
    }


    /**
     * Retrieves the active access key associated with the specified email.
     *
     * @param email the email of the user whose active access key is to be retrieved.
     * @return an Optional containing the active access key if found, otherwise an empty Optional.
     */
    public Optional <AccessKeys> getActiveKeyByStatus(String email){
        Status status = Status.ACTIVE;
        var user = this.userService.getUserByEmail(email);
        return this.accessKeyRepo.findByStatusAndUser(status,user);
    }


    /**
     * Retrieves a paginated list of all access key details.
     *
     * @param page the page number to retrieve (1-based index).
     * @param size the number of items per page.
     * @return a Page containing AccessKeyDetails objects.
     */
    public Page <AccessKeyDetails> getAllAccessKeyDetails(int page, int size){
        Pageable pageable = PageRequest.of(page -1, size);
        Page<AccessKeys> accessKeysPage = accessKeyRepo.findAll(pageable);
        return accessKeysPage.map(this::convertToAccessKeyDetails);
    }


    /**
     * Converts an AccessKeys entity to an AccessKeyDetails DTO.
     *
     * @param accessKeys the AccessKeys entity to convert.
     * @return the corresponding AccessKeyDetails object.
     */
    private AccessKeyDetails convertToAccessKeyDetails(AccessKeys accessKeys){
        AccessKeyDetails keyDetails = new AccessKeyDetails();
        keyDetails.setEmail(accessKeys.getUser().getEmail());
        keyDetails.setKeyValue(accessKeys.getKeyValue());
        keyDetails.setStatus(accessKeys.getStatus());
        keyDetails.setProcured_date(accessKeys.getProcuredDate());
        keyDetails.setExpiry_date(accessKeys.getExpiryDate());

        return keyDetails;
    }

    /**
     * Sorts a list of AccessKeyDetails based on the specified criteria.
     *
     * @param sortBy the attribute to sort by ("email", "procureddate", or "status").
     * @return a sorted list of AccessKeyDetails.
     */
    public List<AccessKeyDetails> sortKeys(String sortBy) {
        List<AccessKeyDetails> allKeys = new ArrayList<>(getAllAccessKeys());

        switch (sortBy.toLowerCase()) {
            case "email":
                allKeys.sort(Comparator.comparing(AccessKeyDetails::getEmail));
                break;
            case "procureddate":
                allKeys.sort(Comparator.comparing(AccessKeyDetails::getProcured_date));
                break;
            case "status":
                allKeys.sort(Comparator.comparing(AccessKeyDetails::getStatus));
                break;
            default:
                break;
        }

        return allKeys;
    }


    /**
     * Revokes an access key based on the user's email and the key value.
     *
     * @param email the email of the user.
     * @param keyValue the value of the access key to be revoked.
     * @return the updated AccessKeys object with the revoked status.
     * @throws NotFoundException if the access key is not found.
     * @throws BadRequestException if the key is already expired or revoked.
     */
    public AccessKeys revoke(String email, String keyValue) throws Exception{
        var key = this.accessKeyRepo.findAccessKeysByKeyValueAndUser(keyValue,this.userService.getUserByEmail(email));
        if (!key.isPresent()){
            throw new NotFoundException("Key Not Found");
        }
        else if(key.get().getStatus().equals(Status.EXPIRED)){
            throw new BadRequestException("This Key is Expired");
        }
        else if(key.get().getStatus().equals(Status.REVOKED)){
            throw new BadRequestException(("This Key is Revoked"));
        }
        key.get().setStatus(Status.REVOKED);
        return this.accessKeyRepo.save(key.get());
    }

    /**
     * Revokes the active access key associated with the specified email.
     *
     * @param email the email of the user.
     * @return the updated AccessKeys object with the revoked status.
     * @throws BadRequestException if the user has no active key.
     */
    public AccessKeys revokeKey(String email) throws BadRequestException{

            log.info("The email for the key {}",email);
            // Get the key of the user.
            var accessKey = this.accessKeyRepo.findByStatusAndUser(Status.ACTIVE,this.userService.getUserByEmail(email));

            if (accessKey.isEmpty()){
                throw new BadRequestException("This user has no active key");
            }
            else {
                log.info("This is the key value {}", accessKey.get().getKeyValue());
                accessKey.get().setStatus(Status.REVOKED);
                return this.accessKeyRepo.save(accessKey.get());
            }

    }

    /**
     * Generates a new AccessKeys object for the specified user email.
     *
     * @param email the email of the user for whom the access key is generated.
     * @return the newly created AccessKeys object.
     */
    private AccessKeys generatAccessKeys(String email){
        Date currentDate = new Date(System.currentTimeMillis());
        AccessKeys accessKey = new AccessKeys();
        accessKey.setKeyValue(keyValue());
        accessKey.setProcuredDate(currentDate);
        accessKey.setExpiryDate(calculateExpiryDate(currentDate));
        accessKey.setStatus(Status.ACTIVE);
        accessKey.setUser(this.userService.getUserByEmail(email));
        return accessKey;
    }

    /**
     * Checks if the user with the specified email has an active access key.
     *
     * @param email the email of the user.
     * @return true if the user has an active access key, false otherwise.
     */
    public boolean userHasActiveKey(String email){
        return getActiveKeyByEmail(email)!=null;
    }

    /**
     * Generates a new access key for the specified user email.
     *
     * @param email the email of the user.
     * @return the newly generated AccessKeys object.
     * @throws BadRequestException if the user already has an active key.
     */

    @ResponseStatus(HttpStatus.BAD_REQUEST)
    public AccessKeys generateKey(String email) throws BadRequestException {
        // Check if user already has an active key
        if (userHasActiveKey(email)) {
            throw new BadRequestException("You already have an active key");
        }

        // Generate and save a new access key
        AccessKeys key = generatAccessKeys(email);
        return this.accessKeyRepo.save(key);
    }

    /**
     * Generates a random key value.
     *
     * @return a randomly generated key value as a String.
     */
    private String keyValue (){
        String values = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrsquvwxyz1234567890";
        Random rand = new Random();
        StringBuilder generatedValue = new StringBuilder();
         for (int i = 0; i < 32; i++){
            generatedValue.append(values.charAt(rand.nextInt(values.length())));
         }
         return generatedValue.toString();
    }

    /**
     * Calculates the expiry date based on the procured date.
     *
     * @param procuredDate the date the key was procured.
     * @return the expiry date, which is one day after the procured date.
     */
    private Date calculateExpiryDate(Date procuredDate){
        LocalDate currDate = procuredDate.toLocalDate();
        LocalDate expiryDate = currDate.plusDays(1);
        return Date.valueOf(expiryDate);
    }

    /**
     * Retrieves all access keys.
     *
     * @return a list of all AccessKeys objects.
     */
    public List <AccessKeys> getAllKeys(){
        return this.accessKeyRepo.findAll();
    }

    /**
     * Saves the specified access key.
     *
     * @param key the AccessKeys object to be saved.
     * @return the saved AccessKeys object.
     */
    public AccessKeys saveAccessKey(AccessKeys key){
        return this.accessKeyRepo.save(key);
    }


}
